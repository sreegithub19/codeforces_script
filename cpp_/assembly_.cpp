#include <iostream>

int main() {
    // Inline assembly code
    __asm__ __volatile__ (
        ".section .data\n\t"
        "hello1: .asciz \"Hello world!\"\n\t"
        "sum_msg: .asciz \"The sum of 14 and 10 is: \"\n\t"
        "sub_msg: .asciz \"The difference of 14 and 10 is: \"\n\t"
        "mul_msg: .asciz \"The product of 14 and 10 is: \"\n\t"
        "div_msg: .asciz \"The quotient of 14 and 10 is: \"\n\t"
        "newline: .byte 10, 0\n\t"
        "result: .asciz \"0000\"\n\t"
        ".section .bss\n\t"
        ".section .text\n\t"
        ".global _start\n\t"
        "_start:\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea hello1(%rip), %rsi\n\t"
        "mov $13, %rdx\n\t"
        "syscall\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea newline(%rip), %rsi\n\t"
        "mov $1, %rdx\n\t"
        "syscall\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea sum_msg(%rip), %rsi\n\t"
        "mov $26, %rdx\n\t"
        "syscall\n\t"
        "mov $14, %rax\n\t"
        "add $10, %rax\n\t"
        "call print_result\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea newline(%rip), %rsi\n\t"
        "mov $1, %rdx\n\t"
        "syscall\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea sub_msg(%rip), %rsi\n\t"
        "mov $33, %rdx\n\t"
        "syscall\n\t"
        "mov $14, %rax\n\t"
        "sub $10, %rax\n\t"
        "call print_result\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea newline(%rip), %rsi\n\t"
        "mov $1, %rdx\n\t"
        "syscall\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea mul_msg(%rip), %rsi\n\t"
        "mov $29, %rdx\n\t"
        "syscall\n\t"
        "mov $14, %rax\n\t"
        "imul $10, %rax\n\t"
        "call print_result\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea newline(%rip), %rsi\n\t"
        "mov $1, %rdx\n\t"
        "syscall\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea div_msg(%rip), %rsi\n\t"
        "mov $31, %rdx\n\t"
        "syscall\n\t"
        "mov $14, %rax\n\t"
        "xor %rdx, %rdx\n\t"
        "mov ten(%rip), %rbx\n\t"
        "div %rbx\n\t"
        "call print_result\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea newline(%rip), %rsi\n\t"
        "mov $1, %rdx\n\t"
        "syscall\n\t"
        "mov $60, %rax\n\t"
        "xor %rdi, %rdi\n\t"
        "syscall\n\t"
        "print_result:\n\t"
        "xor %rcx, %rcx\n\t"
        "mov $10, %rbx\n\t"
        "convert_loop:\n\t"
        "xor %rdx, %rdx\n\t"
        "div %rbx\n\t"
        "add $'0', %dl\n\t"
        "mov %dl, result(%rcx)\n\t"
        "inc %rcx\n\t"
        "test %rax, %rax\n\t"
        "jnz convert_loop\n\t"
        "lea result(%rip), %rsi\n\t"
        "lea result(%rip), %rdi\n\t"
        "add %rcx, %rdi\n\t"
        "dec %rdi\n\t"
        "reverse_loop:\n\t"
        "cmp %rsi, %rdi\n\t"
        "jge end_reverse\n\t"
        "mov (%rsi), %al\n\t"
        "mov (%rdi), %bl\n\t"
        "mov %bl, (%rsi)\n\t"
        "mov %al, (%rdi)\n\t"
        "inc %rsi\n\t"
        "dec %rdi\n\t"
        "jmp reverse_loop\n\t"
        "end_reverse:\n\t"
        "mov $1, %rax\n\t"
        "mov $1, %rdi\n\t"
        "lea result(%rip), %rsi\n\t"
        "mov %rcx, %rdx\n\t"
        "syscall\n\t"
        "ret\n\t"
        ".section .data\n\t"
        "ten: .quad 10\n\t"
    );

    return 0;
}